# Максимальный элемент по предикату

### Условие

Реализуйте шаблонную функцию 
```c++
template<typename ForwardIterator, typename UnaryPredicate>
ForwardIterator max_element_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred);
```
возвращающую итератор на максимальный элемент в диапазоне `[first, last)`, для которого предикат `pred` возвращает `true`. Если диапазон содержит несколько подходящих элементов с максимальным значением, то результатом будет первое вхождение такого элемента. Если диапазон не содержит подходящих элементов, то функция должна вернуть `last`.  

Гарантируется, что:

* pred принимает аргумент того типа, который имеют элементы диапазона
* для ForwardIterator определены операторы ++, ==, !=, * (разыменование)
* для типа, на который указывает итератор, определён оператор < («меньше»)

Заготовка решения:

[max_element_if.cpp](max_element_if.cpp)


P.S. В файле `max_element_if.cpp` используется заголовочный файл `test_runner.h`. Это юнит-тест фреймворк, который мы разработали в «Жёлтом поясе по C++».

[test_runner.h](test_runner.h)







