# Демографические показатели

### Условие
 
Напишите шаблонную функцию `MergeSort`, принимающую два итератора шаблонного типа `RandomIt` и сортирующую заданный ими диапазон с помощью сортировки слиянием. Гарантируется, что:

* итераторы типа `RandomIt` аналогичны по функциональности итераторам вектора и строки, то есть их можно сравнивать с помощью операторов `<`, `<=`, `>` и `>=`, а также вычитать и складывать с числами;
* сортируемые объекты можно сравнивать с помощью оператора `<`.

```c++
1   template <typename RandomIt>
2   void MergeSort(RandomIt range_begin, RandomIt range_end);
```

### Часть 1. Реализация с разбиением на 2 части

#### Алгоритм

Классический алгоритм сортировки слиянием выглядит следующим образом:

1) Если диапазон содержит меньше 2 элементов, выйти из функции.
2) Создать вектор, содержащий все элементы текущего диапазона.
3) Разбить вектор на две равные части. (В этой задаче гарантируется, что длина передаваемого диапазона является степенью двойки, так что вектор всегда можно разбить на две равные части.)
4) Вызвать функцию `MergeSort` от каждой половины вектора.
5) С помощью алгоритма `std::merge` слить отсортированные половины, записав полученный отсортированный диапазон вместо исходного.

Вы должны реализовать именно этот алгоритм и никакой другой: тестирующая система будет проверять, что вы выполняете с элементами именно эти действия.

### Пример кода

```c++
1   int main(){
2     vector<int> v = {6, 4, 7, 6, 4, 4, 0, 1};
3     MergeSort(begin(v), end(v));
4     for (int x : v) {
5       cout << x << " ";
6     }
7     cout << endl;
8     return 0;
9   }
```

### Вывод

```objectivec
1   0 1 4 4 4 6 6 7
```

### Часть 2. Реализация с разбиением на 3 части

Реализуйте сортировку слиянием, разбивая диапазон на 3 равные части, а не на 2. Гарантируется, что длина исходного диапазона является степенью 3.

Соответственно, пункты 3–5 алгоритма нужно заменить следующими:

* Разбить вектор на 3 равные части.
* Вызвать функцию `MergeSort` от каждой части вектора.
* Слить первые две трети вектора с помощью алгоритма merge, сохранив результат во временный вектор с помощью `back_inserter`.
* Слить временный вектор из предыдущего пункта с последней третью вектора из п. 2, записав полученный отсортированный диапазон вместо исходного.

### Пример кода

```c++
1   int main() {
2     vector<int> v = {6, 4, 7, 6, 4, 4, 0, 1, 5};
3     MergeSort(begin(v), end(v));
4     for (int x : v) {
5       cout << x << " ";
6     }
7     cout << endl;
8     return 0;
9   }
```

```objectivec
1   0 1 4 4 4 5 6 6 7
```